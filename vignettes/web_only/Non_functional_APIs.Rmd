---
title: "Non-functional APIs"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Non-functional APIs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r library, include=FALSE}
library(happign)
library(stars)
library(purrr)
library(dplyr)
library(httr)
library(xml2)
library(DT)
```

# Context
To ensure a viable service, the APIs accessible with happign are tested for errors every 12:00 AM on Sunday. If you also detect non-viable APIs, please describe your problem [here](https://github.com/paul-carteron/happign/issues).

<br/>

# WFS

```{r WFS, include=FALSE}
# ---- function ----
format_url <- function(apikey = NULL, layer_name = NULL) {
   url <- modify_url("https://wxs.ign.fr",
                     path = paste0(apikey, "/geoportail/wfs"),
                     query = list(
                        service = "WFS",
                        version = "2.0.0",
                        request = "GetFeature",
                        outputFormat = "json",
                        srsName = "EPSG:4326",
                        typeName = layer_name,
                        bbox = "-4.375615,47.79683,-4.373898,47.79859,epsg:4326"
                     )
   )
   return(url)
}

# ---- WFS ----
start_time <- Sys.time()

all_metadata = get_apikeys() %>%
   set_names() %>% 
   map_df(.f = ~ get_layers_metadata(., "wfs"), .id = "apikey") %>%
   mutate(url = pmap_chr(., ~ format_url(..1, ..3))) %>%
   mutate(status_code = pmap_chr(., ~ status_code(GET(..10)))) 

end_time <- Sys.time()
time <- end_time - start_time

errors <- all_metadata %>%
   filter(status_code != "200") %>%
   mutate(error = pmap_chr(., ~ as.character(xml_child(content(GET(..10)), 1))))

```

Testing all **`r nrow(all_metadata)`** WFS resources took **`r round(as.numeric(time, units="mins"),2)`** mins.

There is **`r nrow(errors)`** request that return an HTTP error 400 (Bad Request) of WFS service. Details of bad urls and errors they return are displayed below :

```{r plot_WFS_error, echo=FALSE}
errors_plot <- errors %>%
   select("apikey", "name", "url", "error")

DT::datatable(errors_plot,
              options = list(pageLength = 5,
                             scrollX = '400px'),
              filter = 'top')

```

<br/>

# WMS raster

```{r WMS, include=FALSE}
# ---- function ----
format_wms_url <- function(apikey = NULL, layer_name = NULL) {
   url <- modify_url("https://wxs.ign.fr",
                     path = paste0(apikey, "/geoportail/r/wms"),
                     query = list(version = "1.3.0",
                                  request = "GetMap",
                                  format = "image/geotiff",
                                  layers = layer_name,
                                  styles = "",
                                  width = "20",
                                  height = "13",
                                  crs = "EPSG:4326",
                                  bbox = "47.79683,-4.375615,47.79859,-4.373898"))
   return(url)
}

# ---- WFS ----
all_metadata <- get_apikeys() %>%
   set_names() %>%
   map(.f = ~ try(get_layers_metadata(., "wms")), .id = "apikey")

no_resources <- all_metadata %>% 
   keep(~ dim(.)[1] == 0) %>% 
   names()

resources_to_test <- all_metadata %>% 
   keep(~ dim(.)[1] != 0) %>%
   map(~ as.list(.x[[2]])) %>% 
   map(~ flatten_chr(.x)) %>% 
   map_df(~ as.data.frame(.x), .id = "apikey") %>% 
   rename("layer_name" = ".x") %>% 
   mutate(url = pmap_chr(., ~ format_wms_url(..1, ..2)))

# readable with vsi_handles
start_time_vsi <- Sys.time()

vsi_testing <- resources_to_test %>% 
   mutate(resp = pmap_chr(., ~ try(
      names(read_stars(paste0("/vsicurl/",..3),
                       normalize_path = FALSE)))))
vsi_error <- vsi_testing %>% 
   filter(substr(resp, 1, 5) == "Error") %>% 
   select(1:2)

end_time_vsi <- Sys.time()
vsi_time <- end_time_vsi - start_time_vsi

# http error 
start_time_http = Sys.time()

http_testing <- resources_to_test %>%
   mutate(status_code = pmap_chr(., ~ status_code(GET(..3))))

http_errors <- http_testing %>%
   filter(status_code != "200") %>%
   mutate(error = pmap_chr(., ~ as.character(xml_child(content(GET(..6)), 1))))

end_time_http <- Sys.time()
http_time <- end_time_http - start_time_http
```

## http error

Testing all **`r nrow(resources_to_test)`** WMS resources for http errors took **`r round(as.numeric(http_time, units="mins"),2)`** mins.

There is **`r nrow(http_errors)`** request that return an HTTP error of WFS service. Details of bad urls and errors they return are displayed below :

```{r plot_wms_http_error, echo=FALSE}

DT::datatable(http_errors,
              options = list(pageLength = 10,
                             scrollX = '400px'),
              filter = 'top')

```

## Unreadable layer by `happign`

For some API, no connection can be established by GDAL because of how resources are formatted on the IGN database. This also means that the `get_wms_raster` function can't connect to the layer. To avoid this problem you just have to **set a name for the `filename` argument** (for example : `get_wms_layer(shape, "satellite", "ORTHOIMAGERY.ORTHO-SAT.PLEIADES.2017", filename = "best_layer_name_ever")`). When a file name is set, the layer is directly download on disk, so be careful with area of your shape.

Testing all **`r nrow(resources_to_test)`** WFS resources took **`r round(as.numeric(vsi_time, units="mins"),2)`** mins.

There are **`r length(no_resources)` ** categories that have no WMS raster resources : **`r paste0(no_resources, collapse  =", ")` **.

There are **`r nrow(vsi_error)`** resources that can't be read by `happign` for the moment. Details of them are displayed below :

```{r plot_wms_vsi_error, echo=FALSE}

DT::datatable(vsi_error,
              options = list(pageLength = 10,
                             scrollX = '400px'),
              filter = 'top')

```
